# This workflow is meant to run govulncheck on all the branches
# that are containing a maintained version of OpenTofu.
# For more considerations about this, check this PR: https://github.com/opentofu/opentofu/pull/2600
#
# This will attempt to create an issue with the results for each scanned version
# in case any vulnerability is found. If the issue for the scanned branch already exists
# the run will just print the scan output and will leave the issue untouched.
#
# This is meant to run _only_ from the main branch, on a scheduled manner.
# All the other branches will be scanned directly by the run triggered from the main branch.

name: Govulncheck

on:
  schedule:
    - cron: '42 3 * * SUN'
  workflow_dispatch: {}
  push:
    branches:
      - govulncheck-action

jobs:
  gather-branches:
    name: Collect the branches that needs to be scanned
    runs-on: ubuntu-latest
    #if: github.ref == 'refs/heads/main'
    env:
      GH_TOKEN: ${{ github.token }}
    outputs:
      branches: ${{ steps.branches.outputs.branches }}
    steps:
      - id: branches
        run: |
          ## This is using GitHub API and we manually filter out the versions that are not supported anymore
          # gh api "repos/opentofu/opentofu/branches?protected=true" --paginate | tee out 
          # cat out | jq '.[] | select(.name != "v1.6") | [.name]' | jq -sc 'add' | tee branches
          # echo "branches=$(cat branches)">> "$GITHUB_OUTPUT"
          
          ## This is using https://endoflife.date since there 1.6 is already marked as it reached EOL
          ## This is adding manually the main branch to scan it as well
          curl https://endoflife.date/api/opentofu.json | tee out 
          cat out | jq '.[] | select(.eol == false) | ["v" + .cycle]' | jq -sc 'add' | jq -c '["main"] + .' | tee branches
          echo "branches=$(cat branches)">> "$GITHUB_OUTPUT"
  govulncheck:
    name: Run govulncheck for ${{ matrix.branch }}
    needs: gather-branches
    runs-on: ubuntu-latest
    #if: github.ref == 'refs/heads/main'
    strategy:
      matrix:
        branch: ${{ fromJSON(needs.gather-branches.outputs.branches )}}
      fail-fast: false
    steps:
      - name: Checkout branch to be scanned
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          ref: ${{matrix.branch}}

      - name: Determine Go version
        id: go
        uses: ./.github/actions/go-version

      - name: Install Go toolchain
        uses: actions/setup-go@f111f3307d8850f501ac008e886eec1fd1932a34 # v5.3.0
        with:
          go-version: ${{steps.go.outputs.version}}

      - name: Install govulncheck
        run: go install golang.org/x/vuln/cmd/govulncheck@v1.1.4
        shell: bash

      - name: Run and report govulncheck findings
        run: |
          govulncheck -format json ./... | tee results
          # This is parsing the output of govulncheck by:
          # * extracting only the findings that are affecting the current branch (.finding | select(.trace | length > 1))
          # * getting only the vulnerability key out of the objects (.osv)
          # * sorting and deduplicating the generated vulnerability keys (sort -u)
          # * compacting the result into a json array like ["vulnKey1", "vulnKey2", ...] (jq -cs '.')
          # * saving the results into a file which name is the version that we are scanning like "v1.8" (> "${{matrix.branch}}")
          cat results | jq '.finding | select(.trace | length > 1) | .osv' | sort -u | jq -cs '.' > "${{matrix.branch}}"
        shell: bash

      # Upload the artifact to make it available to the next job.
      # The artifact will be named as the branch name that we are scanning ("main" or "v1.7"...)
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{matrix.branch}}-results
          path: ${{matrix.branch}}

  create-issues:
    name: Compile results and create GH issues
    needs:
    - govulncheck
    runs-on: ubuntu-latest
    #if: github.ref == 'refs/heads/main'
    env:
      GH_TOKEN: ${{ github.token }}
    steps:
      # By providing the path where to download the artifacts and "merge-multiple: true", the downloader
      # will gather all the files generated in the job(s) above into a single directory flattening the file tree.
      # Eg: Instead of writing the results into "results/main-results/main" it will write the results into "results/main"
      - name: Download vulns results
        uses: actions/download-artifact@v4
        with:
          path: results
          merge-multiple: true
      - name: Run and report govulncheck findings
        run: |
          # Convert the results of type ["vulnKey1", "vulnKey2", ...] in files named like "main", "v1.7", etc to a struct of structure like
          # {"vulnKey1": ["main", "v1.7", ...], "vulnKey2": ["main", "v1.7", ...]}
          
          # Start the script with an empty json object
          vuln_to_versions="{}"
          cd results
          for version in *; do
            while IFS= read -r vuln;
            do
              [[ -z "${vuln}" ]] && continue
              # Actions from this like:
              # * is giving the shell var for the vulnerability key to jq (--arg vl "${vuln}") 
              # * is giving the shell var that contains the scanned version to jq (--arg vers "${version}"
              # * is getting from vuln_to_versions the key name that needs to be a vulnerability key and assigns to its array the currently proceesed version ('.[$vl] = .[$vl] + [$vers]')
              # * this is generating outputs like {"vulnKey": ["version1", "version2"]}. Eg: {"GO-2024-2947":["v1.7"]}
              # * in the end overwrites the content of vuln_to_versions with the newly generated content 
              vuln_to_versions="$(echo "${vuln_to_versions}" | jq -c --arg vl "${vuln}" --arg vers "${version}" '.[$vl] = .[$vl] + [$vers]')"
            done <<< "$(cat $version | jq -r '.[]')" # This one is exploding a json array into multiple lines
          done
          
          # This is just using the ".key" that is the vulnerability key and ".value" that is the list of affected version(s)
          # to generate the commmands to create GitHub issues.
          while IFS= read -r vuln; 
          do 
            vuln_key="$(echo ${vuln} | jq -r '.key')"
            affected_versions="$(echo ${vuln} | jq -r '.value[]' | xargs)"
            ticket_title="${vuln_key} reported"

            reported_issues="$(gh issue -R opentofu/opentofu list --search "\"${ticket_title}\" state:open" --json number)"
            no_of_issues="$(echo ${reported_issues} | jq -r '. | length')"
            reported_issues="$(echo $reported_issues| jq -r '.[] | .number' | xargs)"
            [[ ${no_of_issues} -ge 1 ]] && echo "Vulnerabilties found but already reported for ${vuln_key} in: ${reported_issues}" && exit 0
          
            echo "This vulnerability is affecting the following versions: ${affected_versions}" > ticket_content
            echo "" >> ticket_content
            echo "*Vulnerability info:* https://pkg.go.dev/vuln/${vuln_key}" >> ticket_content
            echo "*Pipeline run:* ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" >> ticket_content
            # gh issue create --repo opentofu/opentofu --title "${ticket_title}" --body-file ticket_content
            echo "Create issue..."
            echo "Title: ${ticket_title}"
            echo "Content:"
            cat ticket_content
            echo "---------"
            echo "---------"
          done <<< "$(echo "$vuln_to_versions"  | jq -c 'to_entries[]')"
          # ^ This is converting a json object that looks something like: 
          # {"GO-2024-2947":["v1.7"],"GO-2024-2948":["v1.7"],...} 
          # to a list of objects, each on its own line
          # {"key":"GO-2024-2947","value":["v1.7"]}
          # {"key":"GO-2024-2948","value":["v1.7"]}
          # ...

        shell: bash